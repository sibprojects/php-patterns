# Паттерны проектирования

### Abstract Factory
Абстрактная фабрика (Abstract Factory) - это паттерн проектирования, который предоставляет интерфейс для создания семейств взаимосвязанных или взаимозависимых объектов без указания их конкретных классов. Он позволяет создавать объекты, которые соответствуют определенному интерфейсу, но скрывает конкретную реализацию от клиента.

Главная идея абстрактной фабрики состоит в том, что она выступает в роли фабрики фабрик. То есть она определяет интерфейс для создания фабрик, которые в свою очередь создают конкретные объекты. Таким образом, абстрактная фабрика обеспечивает создание объектов, связанных друг с другом, без явного упоминания их классов.

Основные компоненты абстрактной фабрики:

<ol>
  <li>Абстрактная фабрика (AbstractFactory): определяет интерфейс для создания семейств связанных объектов.</li>
  <li>Конкретная фабрика (ConcreteFactory): реализует интерфейс абстрактной фабрики и создает конкретные объекты.</li>
  <li>Абстрактные продукты (AbstractProduct): определяют интерфейс для различных типов продуктов, создаваемых фабрикой.</li>
  <li>Конкретные продукты (ConcreteProduct): реализуют интерфейс абстрактных продуктов.</li>
</ol>

Применение абстрактной фабрики позволяет создавать семейства связанных объектов, гарантируя их совместимость. Клиентский код работает с абстрактными классами и интерфейсами, что позволяет ему быть независимым от конкретных классов продуктов, которые создаются.

Преимущества использования абстрактной фабрики:

<ol>
  <li>Гарантирует совместимость создаваемых объектов.</li>
  <li>Изолирует клиентский код от конкретных классов продуктов.</li>
  <li>Упрощает замену семейства продуктов, так как клиентский код зависит только от абстрактных классов и интерфейсов.</li>
  <li>Позволяет легко добавлять новые варианты продуктов и фабрик, не изменяя существующий код.</li>
</ol>

Однако, следует учитывать, что абстрактная фабрика может стать сложной в поддержке, особенно если семейств продуктов часто меняются или расширяются. Также, в случае добавления нового продукта, потребуется внести изменения во все существующие фабрики, что может быть трудоемким.


### Builder
Паттерн Builder (Строитель) - это порождающий паттерн проектирования, который разделяет процесс создания сложного объекта от его представления. Он позволяет создавать сложные объекты шаг за шагом, абстрагируя процесс конструирования от конечного представления объекта. Основная идея паттерна Builder заключается в предоставлении четкого, пошагового подхода к созданию объектов, не раскрывая детали их конструирования.

Назначение:
Паттерн Builder используется, когда необходимо создавать сложные объекты с различными конфигурациями и частями. Он особенно полезен, когда:

<ol>
  <li>Объект, который вы хотите создать, имеет несколько компонентов или частей с различными конфигурациями.</li>
  <li>Процесс создания объекта сложен и должен быть абстрагирован.</li>
  <li>Представление объекта может изменяться, и вы хотите скрыть внутренние детали процесса создания.</li>
</ol>

Компоненты паттерна Builder:

<ol>
  <li>Builder (Строитель): Определяет общий интерфейс для создания различных частей сложного объекта.</li>
  <li>ConcreteBuilder (Конкретный строитель): Реализует интерфейс Builder для конструирования и сборки конкретных частей объекта.</li>
  <li>Product (Продукт): Представляет сложный объект, который должен быть построен с помощью паттерна Builder.</li>
  <li>Director (Директор): Управляет порядком вызовов методов строителя для построения объекта. Может содержать логику пошагового конструирования объекта.</li>
</ol>

Пример использования паттерна Builder:

Представим, что у нас есть строительство дома, который может иметь различные характеристики, такие как количество комнат, наличие бассейна, тип крыши и т.д. Каждый дом строится в разной последовательности, и у нас есть несколько типов домов, которые мы можем построить.

В этом случае, класс HouseBuilder будет представлять Builder, а ConcreteHouseBuilder - ConcreteBuilder. Для управления процессом строительства дома может использоваться класс Director.

При использовании паттерна Builder, мы можем легко создавать различные типы домов, не изменяя логику строительства. Это позволяет нам добавлять новые типы домов без изменения существующего кода, обеспечивая легкую расширяемость и поддерживаемость системы.


### Factory method

Паттерн программирования "Фабричный метод" (Factory Method) относится к классу паттернов проектирования "Порождающие". Он предоставляет интерфейс для создания объектов, но позволяет подклассам решать, какие классы инстанцировать. Таким образом, данный паттерн делегирует создание объектов подклассам, а не основному классу.

Основная идея "Фабричного метода" заключается в том, что вместо непосредственного вызова конструктора для создания объектов, используется метод-фабрика. Этот метод определен в интерфейсе или абстрактном классе и реализуется различными подклассами, чтобы создавать различные типы объектов.

Преимущества паттерна Factory Method:

<ol>
  <li>Позволяет избавить клиентский код от зависимости от конкретных классов продуктов, так как он оперирует только с абстрактными типами через интерфейс создания.</li>
  <li>Позволяет добавлять новые продукты, не меняя существующий код фабрик и клиентов.</li>
  <li>Скрывает сложности создания объектов и делегирует их ответственность соответствующим фабрикам.</li>
</ol>

### Prototype

Паттерн Prototype (Прототип) относится к классу порождающих паттернов проектирования и используется для создания объектов путем клонирования существующего объекта, вместо создания нового объекта с нуля. Таким образом, он позволяет создавать копии объектов, избегая избыточного кода для их инициализации.

Основная идея паттерна Prototype заключается в создании абстрактного базового класса, который содержит метод клонирования. Подклассы этого базового класса переопределяют метод клонирования, чтобы создать свои собственные копии объектов.

Применение паттерна Prototype позволяет уменьшить количество классов в программе и способствует гибкости создания новых объектов, так как изменения в классах не затрагивают процесс их клонирования.

Пример использования паттерна Prototype может быть, когда у нас есть сложный объект, который требует много ресурсов для инициализации, и мы хотим создать много подобных объектов с разными значениями без повторного инициализации всех данных.

### Одиночка (Singleton)

Одиночка - это порождающий шаблон, который гарантирует существование только одного объекта определенного класса и также позволяет получить доступ к этому объекту откуда угодно в программе.

Одиночка имеет те же преимущества и недостатки, что и глобальные переменные. Его удобно использовать, но он нарушает модульность вашего кода.

Вы не можете просто взять и использовать класс, зависящий от одиночки, в другой программе. Для этого вам придется эмулировать наличие одиночки и там. Эта проблема чаще всего проявляется при написании модульных тестов.

### Паттерн Adapter
Адаптер — это структурный шаблон проектирования, который позволяет несовместимым объектам взаимодействовать друг с другом.

Адаптер действует как прослойка между двумя объектами, преобразуя вызовы от одного объекта в вызовы, которые понятны другому.

### Паттерн Мост (Bridge)
Мост (Bridge) — это структурный шаблон проектирования, который разделяет бизнес-логику или большой класс на несколько отдельных иерархий, которые затем могут развиваться независимо друг от друга.

Одна из этих иерархий (абстракция) будет ссылаться на объекты другой иерархии (реализация) и делегировать им основную работу. Поскольку все реализации будут следовать общему интерфейсу, их можно будет взаимозаменять в рамках абстракции.

### Паттерн Anti-corruption Layer

Паттерн Anti-corruption Layer (слой антикоррупции) применяется в разработке программного обеспечения для изоляции собственной системы от изменений или несовместимостей внешних систем или сторонних сервисов.

Смысл этого паттерна заключается в том, чтобы создать промежуточный слой между внешними системами и собственной системой, который позволит переводить данные и запросы между различными форматами, структурами или протоколами. Такой слой антикоррупции изолирует вашу систему от изменений в сторонних сервисах, предоставляя адаптеры или фасады, которые приводят данные к стандартам вашей системы.

Этот подход позволяет вашей системе оставаться гибкой и независимой от внешних изменений. Вы можете обновлять и изменять ваши внешние интеграции, не затрагивая основной функционал вашей системы. Кроме того, слой антикоррупции упрощает поддержку и расширение системы, так как изменения во внешних сервисах легче адаптировать внутри этого слоя, чем напрямую в основной системе.

### Паттерн Object Pool

Object pool может значительно повысить производительность; это особенно эффективно в ситуациях, где стоимость инициализации экземпляра класса высока, частота создания экземпляра класса высока, а количество одновременно используемых экземпляров невелико.

Object pools (иначе известные как пулы ресурсов) используются для управления кэшированием объектов. Клиенты, имеющие доступ к объектному пулу, могут избежать создания новых объектов, просто запросив у пула объект, который уже был инстанциирован. Обычно пул будет динамическим, то есть он может создавать новые объекты, если пул пуст. В качестве альтернативы, мы можем иметь пул фиксированного размера, который ограничивает количество создаваемых объектов.

Желательно хранить все повторно используемые объекты, которые в данный момент не используются, в одном объектном пуле, чтобы их можно было управлять единообразной политикой. Для достижения этой цели класс Reusable Pool разработан как класс-одиночка.

## Единица работы (Unit of Work)

Шаблон Unit of Work является одним из самых сложных элементов Object-Relational Mappers (ORM), и обычно Data Mappers в целом. Единица работы (Unit of Work) — это компонент (для нас это объект с сотрудниками), который отслеживает новые, измененные и удаленные объекты домена, изменения которых должны быть отражены в хранилище данных. В конце транзакции Unit of Work, если он используется правильно, способен сформировать список изменений для выполнения в хранилище данных, решая проблемы конкуренции или согласованности и избегая избыточных запросов в реляционных базах данных или излишне многословного общения в безсхемных базах данных.

Сила Unit of Work заключается в том, что фактическая транзакция с базой данных выполняется (и остается открытой) только тогда, когда вызывается метод commit() Unit of Work, в то время как до этого момента, идеальным образом, нет необходимости в использовании подключения к базе данных. Этот подход называется пакетным обновлением (batch update).

Объекты, хранящиеся в Unit of Work, обычно имеют связанное состояние, например:
<ol>
  <li>новый (соответствует INSERT-запросам во время пакетного обновления)</li>
  <li>чистый (SQL-запросы не требуются, так как объект был получен и не изменялся)</li>
  <li>измененный (UPDATE-запросы)</li>
  <li>удаленный (DELETE-запросы)</li>
</ol>

Существуют различные стратегии для обнаружения изменений в графе объектов. Самая простая стратегия заключается в сравнении объектов с чистой копией, хранящейся в памяти (так как обычно неэффективно сравнивать их с базой данных).

Более сложное решение заключается в наличии специального интерфейса, который реализуется объектами, чтобы они могли управлять своим состоянием и заявлять, что они изменены или должны быть удалены. Этот выбор реализации вводит зависимость от слоя домена к инфраструктурному, поэтому я предпочитаю более тяжелые подходы, как предыдущий, который эквивалентен созданию diff с вашей системой контроля версий, но на графе объектов вместо кодовой базы: исходные файлы не отвечают за создание diff сами по себе.

Кроме того, развязывание Unit of Work от состояния базы данных вводит верхний уровень управления, который позволяет нам откатывать изменения, если некоторые ограничения не выполнены или вычисления привели к ошибке. В PHP клиентский код может просто отбросить граф объектов, и частичный набор изменений Unit of Work будет забыт в следующих запросах.